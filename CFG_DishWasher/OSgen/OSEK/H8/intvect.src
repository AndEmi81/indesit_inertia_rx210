; file: intvect.src, automatically generated by GENH8.EXE, Version: 3.05
; from: C:\PROGETTI\RTC_DEA700_2_STEP_DEV\CFG_DISHWASHER\OSGEN\OSEK\H8\DW_DEA700_H8.oil
; at  : Thu Sep 06 16:46:04 2012
; Implementation: HitachiH8_3687Group
; Version of general code: 3.33a

   .CPU        300HA:24
   .INCLUDE "tcb_inc.h"

   ;category 1 ISR prototypes
   .IMPORT _StartupCode
   .IMPORT _Isr_NMI
   .IMPORT _osISRUnhandledException


   ;category 2 ISR prototypes
   .IMPORT _ZC_Interrupt
   .IMPORT _Isr_I2C
   .IMPORT _UartRx_Interrupt
   .IMPORT _Isr_Tpm2Overflow
   .IMPORT _osTimerInterrupt

   ; import variables needed by enterISR and leaveISR
   .IMPORT _osIntNestingDepth
   .IMPORT _osLockDispatcher
   .IMPORT _osStartDispatcher
   .IMPORT _oskSystemStackTop
   .IMPORT _oskSystemStackBottom
   .IMPORT L_NO_SAVE_AFTER_INT

   .AIF \&osdORTIDebug EQ 1
   .AIF \&osdORTIVersion EQ 200
    .IMPORT _osORTICurrentServiceId
   .AENDI
   .AENDI

   .AIF "\&osdStackCheck" EQ "1"
    .IMPORT _osSystemStackOverflow
   .AENDI

   .IMPORT _osDispatcher

;---------------------------------------------------
; EnterISR
;---------------------------------------------------
   .MACRO EnterISR
      PUSH.L ER0                                    ; save context
      PUSH.L ER1
      PUSH.L ER2
      PUSH.L ER3
      PUSH.L ER4
      PUSH.L ER5
      PUSH.L ER6
      PUSH.W E7

      MOV.B @_osIntNestingDepth:16, R0L             ; get content of _osIntNestingDepth
      INC.B  R0L                                    ; increment
      MOV.B R0L, @_osIntNestingDepth:16             ; write variable back

      CMP.B #1, R0L                                 ; check if it is the first nesting level
      BNE L_NO_STACK_SWITCH\@                       ; if not first nesting level -> no regsave

      MOV.B @_osLockDispatcher:16, R0L              ; Get osLockDispatcher
      INC.B R0L                                     ; increment
      MOV.B R0L, @_osLockDispatcher:16              ; write back osLockDispatcher

      MOV.W R7, R0                                  ; save SP
      MOV.W @_oskSystemStackTop:osdRomPtr, R7       ; switch to system stack
      PUSH.W R0                                     ; save SP to system stack

   L_NO_STACK_SWITCH\@:

   .AIF \&osdORTIDebug' EQ 1
   .AIF \&osdORTIVersion EQ 200
      MOV.B @_osORTICurrentServiceId:16, R0L        ; get content of ORTI current service ID
      PUSH.W R0                                     ; save ORTI current service ID to stack
      MOV.B #0, R0L                                 ; current service ID = NO SERVICE
      MOV.B R0L, @_osORTICurrentServiceId:16
   .AENDI
   .AENDI

   .ENDM

;---------------------------------------------------
; LeaveISR
;---------------------------------------------------
   .MACRO LeaveISR
      ORC #H'80, CCR                                ; disable all interrupts

   .AIF \&osdORTIDebug' EQ 1
   .AIF \&osdORTIVersion EQ 200
      POP.W R0                                      ; restore the current service id level
      MOV.B R0L, @_osORTICurrentServiceId:16
   .AENDI
   .AENDI

   .AIF "\&osdStackCheck'" EQ "1"
      ; perform system stack check
      MOV.W @_oskSystemStackBottom:osdRomPtr, R0
      EXTS.L ER0
      MOV.B @ER0, R0L
      CMP.B #H'AA, R0L
      BEQ L_RESTORE_LOCAL_VARIABLES\@
      JSR @_osSystemStackOverflow:osdRomPtr

   L_RESTORE_LOCAL_VARIABLES\@:
   .AENDI

      MOV.B @_osIntNestingDepth:16, R0L          ; get content of _osIntNestingDepth
      DEC.B R0L                                  ; decrement
      MOV.B R0L, @_osIntNestingDepth:16          ; write variable back

      CMP.B #0, R0L                              ; check interrupt nesting level
      BNE L_ISR_EXIT\@                           ; if level is not zero->ISR was interrupted by another jump to ISR exit

      POP.W R0                                   ; get saved task SP
      MOV.W R0, R7                               ; switch to task stack

      MOV.B @_osLockDispatcher:16, R0L
      DEC.B R0L                                  ; decrement osLockDispatcher
      MOV.B R0L, @_osLockDispatcher:16

   .AIF "\&osdNonPreempt'" EQ "0"
      CMP.B #0, R0L                              ; check lock dispatcher
      BEQ L_CHECK_START_DISPATCHER\@             ; if dispatcher is unlocked check start dispatcher
      BRA L_ISR_EXIT\@                           ; else return to task

   L_CHECK_START_DISPATCHER\@:
      MOV.B @_osStartDispatcher:16, R0L
      CMP.B #0, R0L                              ;if start dispatcher was not set return to task
      BEQ L_ISR_EXIT\@
      JMP @L_NO_SAVE_AFTER_INT:osdRomPtr       ; jump directly into dispatcher
   .AENDI

   L_ISR_EXIT\@:
      POP.W E7                                   ; restore interrupted task context
      POP.L ER6
      POP.L ER5
      POP.L ER4
      POP.L ER3
      POP.L ER2
      POP.L ER1
      POP.L ER0
      RTE

   .ENDM

   ;cat2 ISR functions

_ZC_Interrupt_cat2:
   EnterISR
   JSR @_ZC_Interrupt:osdRomPtr
   LeaveISR

_Isr_I2C_cat2:
   EnterISR
   JSR @_Isr_I2C:osdRomPtr
   LeaveISR

_UartRx_Interrupt_cat2:
   EnterISR
   JSR @_UartRx_Interrupt:osdRomPtr
   LeaveISR

_Isr_Tpm2Overflow_cat2:
   EnterISR
   JSR @_Isr_Tpm2Overflow:osdRomPtr
   LeaveISR

_osTimerInterrupt_cat2:
   EnterISR
   JSR @_osTimerInterrupt:osdRomPtr
   LeaveISR


   ;Interrupt Vector Table
   .SECTION   VECTAB0,CODE,LOCATE=0 	;INT0_RESET
   .DATA.L _StartupCode
   .SECTION   VECTAB7,CODE,LOCATE=28 	;INT7_External_NMI
   .DATA.L _Isr_NMI
   .SECTION   VECTAB8,CODE,LOCATE=32 	;INT8_Trap0
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB9,CODE,LOCATE=36 	;INT9_Trap1
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB10,CODE,LOCATE=40 	;INT10_Trap2
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB11,CODE,LOCATE=44 	;INT11_Trap3
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB12,CODE,LOCATE=48 	;INT12_Address_Break
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB13,CODE,LOCATE=52 	;INT13_CPU
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB14,CODE,LOCATE=56 	;INT14_Ext_IRQ0
   .DATA.L _ZC_Interrupt_cat2
   .SECTION   VECTAB15,CODE,LOCATE=60 	;INT15_Ext_IRQ1
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB16,CODE,LOCATE=64 	;INT16_Ext_IRQ2
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB17,CODE,LOCATE=68 	;INT17_Ext_IRQ3
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB18,CODE,LOCATE=72 	;INT18_Ext_WKP
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB19,CODE,LOCATE=76 	;INT19_RTC_OVERFLOW
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB22,CODE,LOCATE=88 	;INT22_TimerV
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB23,CODE,LOCATE=92 	;INT23_SCI3
   .DATA.L _UartRx_Interrupt_cat2
   .SECTION   VECTAB24,CODE,LOCATE=96 	;INT24_IIC2
   .DATA.L _Isr_I2C_cat2
   .SECTION   VECTAB25,CODE,LOCATE=100 	;INT25_AD_Converter
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB26,CODE,LOCATE=104 	;INT26_TimerZ0
   .DATA.L _osTimerInterrupt_cat2
   .SECTION   VECTAB27,CODE,LOCATE=108 	;INT27_TimerZ1
   .DATA.L _Isr_Tpm2Overflow_cat2
   .SECTION   VECTAB29,CODE,LOCATE=116 	;INT29_TimerB1
   .DATA.L _osISRUnhandledException
   .SECTION   VECTAB32,CODE,LOCATE=128 	;INT32_SCI3_2
   .DATA.L _osISRUnhandledException
   .END

; END OF C:\PROGETTI\RTC_Dea700_2_STEP_dev\CFG_DishWasher\OSgen\OSEK\H8\intvect.src

