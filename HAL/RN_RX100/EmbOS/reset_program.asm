/*------------------------------------------------------------------------
                                                                       |
   FILE        : reset_program.asm                                     |
   DATE        :  Thu, Sep 08, 2011                                    |
   DESCRIPTION :   Reset Program                                       |
   CPU TYPE    :    Other                                              |
                                                                       |
   This file is generated by KPIT GNU Project Generator (Ver.4.5).     |
                                                                       |
------------------------------------------------------------------------*/
                        
#include "autoconf.h"
#include "WatchDogConfig.h"

/* Start Window values*/
#define START_WINDOW_25     0x0000
#define START_WINDOW_50     0x1000
#define START_WINDOW_75     0x2000
#define START_WINDOW_100    0x3000
/* End Window values*/
#define END_WINDOW_75       0x0000
#define END_WINDOW_50       0x0100
#define END_WINDOW_25       0x0200
#define END_WINDOW_0        0x0300
/*
 * Whatcdog timeout is express in ms.
 * Refers to the table 27.3 of User Manual to set the TIMEOUT
 * The follow parameters should be used:
 *  - Divider: 4,64,128,512,2048,8192,
 *  - Timeout: 0x00 (1024 cycles), 0x01 (4096 cycles), 0x20 (8192 cycles), 0x03 (16384 cycles)
 */
#define RX210_WDT_TIMEOUT_1024      0x00
#define RX210_WDT_TIMEOUT_4096      0x01
#define RX210_WDT_TIMEOUT_8192      0x02
#define RX210_WDT_TIMEOUT_16384     0x03

/** WDT PRESCALER **/
/*
 * The prescaler divided the PCKL
 */
#define RX210_WDT_DIVIDER_1         0x00
#define RX210_WDT_DIVIDER_16        0x20
#define RX210_WDT_DIVIDER_32        0x30
#define RX210_WDT_DIVIDER_64        0x40
#define RX210_WDT_DIVIDER_128       0xF0
#define RX210_WDT_DIVIDER_256       0x50

	/*reset_program.asm*/

    /* Number of words (32 bit) to be checked at this point
       This should fit all stack can ben used until complete RAM check starts */
#define CLB_STACK_CHK_NUM          40

	.list
	.section .text
	.global _PowerON_Reset    /*global Start routine */
	.global ___ram_initialization
	.global	_CopyFlashRoutinesToRAM
	.extern _HardwareSetup  /*external Sub-routine to initialise Hardware*/
	.extern _data
	.extern _mdata
	.extern _ebss
	.extern _bss
	.extern _edata
	.extern _main 
	.extern _ustack
	.extern _istack
	.extern _RelocatableVectors

	.extern	_PFRAM
	.extern _PRAM
	.extern _ePRAM
	
	.extern ___initialize_hardware
	.extern ___lib_reset_manager
#if DEBUG
	.extern _exit
#endif
/**/
___ram_initialization:
/* load data section from ROM to RAM */

	mov     #_mdata,r2      /* src ROM address of data section in R2 */
	mov     #_data,r1       /* dest start RAM address of data section in R1 */
	mov     #_edata,r3      /* end RAM address of data section in R3 */
	sub    r1,r3            /* size of data section in R3 (R3=R3-R1) */
	smovf                   /* block copy R3 bytes from R2 to R1 */

/* bss initialisation : zero out bss */

	mov	#00h,r2  	/* load R2 reg with zero */
	mov	#_ebss, r3  /* store the end address of bss in R3 */
	mov	#_bss, r1 	/* store the start address of bss in R1 */
	sub   r1,r3	   	/* size of bss section in R3 (R3=R3-R1) */
	sstr.b

_CopyFlashRoutinesToRAM:
/* load data section from ROM to RAM */
	mov     #_PRAM, r1       /* dest start RAM address of data section in R1 */
	mov     #_PFRAM,r2      /* src ROM address of data section in R2 */
	mov     #_ePRAM,r3      /* end RAM address of data section in R3 */
	sub     r1,r3            /* size of data section in R3 (R3=R3-R1) */
	smovf                   /* block copy R3 bytes from R2 to R1 */

	rts

_PowerON_Reset:
    /* Set initial offset for registers */
    mov.l #00080000h, r1

#if defined(CONFIG_WDT_ENABLED) && defined(WDT_ENABLED_AT_POWERON)

    /* Disable protection => SYSTEM.PRCR */
    mov.w #0xa501, 0x03fe[r1]

    /* Enable LOCO for IWDT => SYSTEM.ILOCOCR */
    mov.b #0x00, 0x0035[r1]

    /* Enable protection => SYSTEM.PRCR */
    mov.w #0xa500, 0x03fe[r1]

    /* Set IWDT configuration => IWDT.IWDTCR */
    mov.w #(WDT_PRESCALER | WDT_WINDOW_START | WDT_WINDOW_END | WDT_TIMEOUT), 0x8032[r1]

    /* Force reset on IWDT failure => IWDT.IWDTCSTPR */
    mov.b #0x80, 0x8036[r1]

    /* Start IWDT => IWDT.IWDTRR */
    mov.b #0x00, 0x8030[r1]
    mov.b #0xff, 0x8030[r1]

#endif

#if defined(CONFIG_HAL_CLK_FIXED)  && defined(WDT_ENABLED_AT_POWERON)

    /* Disable protection => SYSTEM.PRCR */
    mov.w #0xa503, 0x03fe[r1]

    /* Define Waiting time => SYSTEM.MOSCWTCR */
   mov.b #0x07, 0x00a2[r1]

   /* Set Internal Clock source => SYSTEM.SCKCR3 HOCO*/
   mov.w #0x0100, 0x0026[r1]

   /* Turn ON Internal Clock => SYSTEM.HOCOCR / HOCOCR2 */
   /*mov.b #0x02, 0x0037[r1] la frequenza HOCO e' fissa a 32MHz nel RX100 */
   mov.b #0x00, 0x0036[r1] /* accende l'oscillatore HOCO */

   /* Wait... */
   nop
   nop
   nop
   nop
   nop

    /* SCKCR Define Frequency divider */
    mov.l #0x31000303, 0x0020[r1] /* FCK=1/8  ICK=1/2 PCKB=1/8 PCKD=1/8 */ /*TODO: MS clock verifca */

    /* Enable protection => SYSTEM.PRCR */
    mov.w #0xa500, 0x03fe[r1]
#endif

#if defined(CONFIG_LIB_CLASS_B_CPU) && defined(WDT_ENABLED_AT_POWERON)
    /* Class B CPU : PC Check */
    bra     _Test_PC

_Failure0:

    /* Set initial offset for registers */
    mov.l #00080000h, r1

    /* Disable protection => SYSTEM.PRCR */
    mov.w #0xa502, 0x03fe[r1]
        /* Force reset => SWRR */
    mov.w #0xA501, 0x00C2[r1]
    bra _Failure0

_PowerON_Reset_TestOK:

    /* Class B CPU : Check if one of registers are written properly
       This means PC check has been completed succesfully too */
    cmp #0AAAAAAAAh, R1
    bne _Failure0

    /* Class B CPU : Check USP */
    mvtc    #055555555h, USP
    mvfc    USP, R1
    cmp #055555555h, R1
    bne _Failure0

    mvtc    #0AAAAAAAAh, USP
    mvfc    USP, R1
    cmp #0AAAAAAAAh, R1
    bne _Failure0

    /* Class B CPU : Check ISP */
    mvtc    #055555555h, ISP
    mvfc    ISP, R2
    cmp #055555555h, R2
    bne _Failure0

    mvtc    #0AAAAAAAAh, ISP
    mvfc    ISP, R2
    cmp #0AAAAAAAAh, R2
    bne _Failure0
#endif

/* initialise user stack pointer */
    mvtc    #_ustack, USP

/* initialise interrupt stack pointer */
    mvtc    #_istack, ISP

/* setup intb */
	mvtc	#_RelocatableVectors, intb	/* INTERRUPT VECTOR ADDRESS  definition	*/

/* setup FPSW */
	mvtc    #0x0100, fpsw

#if defined(CONFIG_LIB_CLASS_B_RAM) && defined(WDT_ENABLED_AT_POWERON)
 /* Class B RAM : Preliminary check of CLB_STACK_CHK_NUM words (32bit)
    using checker board.
    Phase 1: Populate all area with 0x55 */
    mov.l   #CLB_STACK_CHK_NUM, R1
    mov.l #055555555h, R2
chk_st_55_push:
    push.l  R2
    sub     #1, R1
    bnz     chk_st_55_push

 /* Class B RAM : Preliminary check of CLB_STACK_CHK_NUM words (32bit)
    using checker board.
    Phase 2: Check area has been filled with 0x55 */
    mov.l   #CLB_STACK_CHK_NUM, R2
chk_st_55_pop:
    pop     R1
    cmp #055555555h, R1
    bne _Failure0

    sub     #1, R2
    bnz     chk_st_55_pop

 /* Class B RAM : Preliminary check of CLB_STACK_CHK_NUM words (32bit)
    using checker board.
    Phase 3: Populate all area with 0xAA */
    mov.l   #CLB_STACK_CHK_NUM, R1
    mov.l #0AAAAAAAAh, R2
chk_st_aa_push:
    push.l  R2
    sub     #1, R1
    bnz     chk_st_aa_push

 /* Class B RAM : Preliminary check of CLB_STACK_CHK_NUM words (32bit)
    using checker board.
    Phase 4: Check area has been filled with 0xAA */
    mov.l   #CLB_STACK_CHK_NUM, R2
chk_st_aa_pop:
    pop     R1
    cmp #0AAAAAAAAh, R1
    bne _Failure0

    sub     #1, R2
    bnz     chk_st_aa_pop

/* Class B RAM Preliminary check succeeded - carry on with initialization */
#endif

	bsr.a	___initialize_hardware
/* call the hardware initialiser */
#ifdef STARTUP_FOR_TEST
	bsr.a	___ram_initialization
#else	
	bsr.a	___lib_reset_manager
#endif	
	
	
	/*bsr.a	_HardwareSetup	*/
	nop

/* setup PSW */
	mvtc	#0x00010000, psw			/* Set Ubit & Ibit for PSW */

/* change PSW PM to user-mode */
/*
	MVFC   PSW,R1
	OR     #00100000h,R1
	PUSH.L R1
	MVFC   PC,R1
	ADD    #10,R1
	PUSH.L R1
	RTE
	NOP
	NOP
*/
#ifdef CPPAPP
    bsr.a	__rx_init
#endif	
/* start user program */
	bsr.a	_main		
	bsr.a 	_exit

#ifdef CPPAPP
	.global	_rx_run_preinit_array
	.type	_rx_run_preinit_array,@function
_rx_run_preinit_array:
	mov	#__preinit_array_start,r1
	mov	#__preinit_array_end,r2
	bra.a	_rx_run_inilist

	.global	_rx_run_init_array
	.type	_rx_run_init_array,@function
_rx_run_init_array:
	mov	#__init_array_start,r1
	mov	#__init_array_end,r2
	mov	#4, r3
	bra.a	_rx_run_inilist

	.global	_rx_run_fini_array
	.type	_rx_run_fini_array,@function
_rx_run_fini_array:
	mov	#__fini_array_start,r2
	mov	#__fini_array_end,r1
	mov	#-4, r3
	/* fall through */

_rx_run_inilist:
next_inilist:
	cmp	r1,r2
	beq.b	done_inilist
	mov.l	[r1],r4
	cmp	#-1, r4
	beq.b	skip_inilist
	cmp	#0, r4
	beq.b	skip_inilist
	pushm	r1-r3
	jsr	r4
	popm	r1-r3
skip_inilist:
	add	r3,r1
	bra.b	next_inilist
done_inilist:
	rts

	.section	.init,"ax"
	.balign 4

	.global __rx_init
__rx_init:

	.section	.fini,"ax"
	.balign 4

	.global __rx_fini
__rx_fini:
	bsr.a	_rx_run_fini_array

        .section .sdata
        .balign 4
        .global __gp
	.weak   __gp
__gp:   

	.section .data
	.global ___dso_handle
	.weak   ___dso_handle
___dso_handle:
	.long	0

     .section        .init,"ax"
     bsr.a   _rx_run_preinit_array
     bsr.a   _rx_run_init_array
     rts
	 
    .global __rx_init_end
__rx_init_end:

    .section        .fini,"ax"

    rts
    .global __rx_fini_end
__rx_fini_end:

#endif

/* call to exit*/
_exit:
	bra  _loop_here
_loop_here:
    bra _loop_here

#if defined(CONFIG_LIB_CLASS_B_CPU) && defined(WDT_ENABLED_AT_POWERON)
    .section .PCTEST_TESTFUNCTION
_Test_PC:
    /* Class B: Start Preliminary check of Register and complete PC Check */
    mov.l #055555555h, R2
    mov.l #055555555h, R1

    cmp R2,R1
    bne _ForceReset

    mov.l #0AAAAAAAAh, R1
    mov.l #0AAAAAAAAh, R2

    cmp R1,R2
    /* Preliminary check of R1, R2 register completed succesfully.
       Now complete PC Check */
    bne _ForceReset
    bra _PowerON_Reset_TestOK

_ForceReset:
    /* Set initial offset for register */
    mov.l #00080000h, r1
    /* Disable protection => SYSTEM.PRCR */
    mov.w #0xa502, 0x03fe[r1]
    /* Force reset => SWRR */
    mov.w #0xA501, 0x00C2[r1]
    bra _ForceReset
#endif

	.text	
	.end
